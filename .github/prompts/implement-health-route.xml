<?xml version="1.0" encoding="UTF-8"?>
<task>
  <metadata>
    <title>Implement Health Check Route with Ferriskey-inspired Architecture</title>
    <version>1.0.0</version>
    <created>2025-11-15</created>
    <priority>high</priority>
    <category>feature-implementation</category>
  </metadata>

  <context>
    <project>
      <name>communities</name>
      <description>Rust workspace project with API and Core business logic members</description>
      <architecture>
        <pattern>Hexagonal Architecture (Ports and Adapters)</pattern>
        <inspiration>https://github.com/ferriskey/ferriskey</inspiration>
        <workspace-structure>
          <member name="api" description="HTTP API layer using Axum framework"/>
          <member name="core" description="Domain logic and infrastructure"/>
        </workspace-structure>
      </architecture>
    </project>

    <existing-implementation>
      <core-layer>
        <domain path="core/src/domain">
          <module name="health">
            <file path="entities.rs">
              <struct name="IsHealthy" description="Value object for health status"/>
            </file>
            <file path="port.rs">
              <trait name="HealthRepository" description="Port for health data access"/>
              <trait name="HealthService" description="Port for health domain service"/>
            </file>
            <file path="services.rs">
              <implementation of="HealthService" for="Service&lt;S, H&gt;"/>
            </file>
          </module>
          <module name="common">
            <file path="services.rs">
              <struct name="Service&lt;S, F&gt;" description="Generic service container with repositories"/>
            </file>
            <file path="entities.rs">
              <enum name="CoreError" description="Domain error types"/>
            </file>
          </module>
        </domain>
        <infrastructure path="core/src/infrastructure">
          <module name="health">
            <file path="repositories/postgres.rs">
              <struct name="PostgresHealthRepository">
                <bug location="ping method" severity="critical">
                  Returns is_err() instead of is_ok() - inverted boolean logic
                </bug>
              </struct>
            </file>
          </module>
        </infrastructure>
      </core-layer>

      <api-layer>
        <structure path="api/src">
          <file path="lib.rs">Contains http module declaration</file>
          <file path="main.rs">Empty - needs implementation</file>
          <module name="http">
            <file path="mod.rs">Contains health module declaration</file>
            <module name="health">
              <file path="mod.rs">Module declarations</file>
              <file path="handler.rs" status="empty"/>
              <file path="router.rs" status="empty"/>
              <file path="validator.rs" status="empty"/>
            </module>
          </module>
        </structure>
        <dependencies status="missing">
          <note>api/Cargo.toml is empty - needs all dependencies</note>
        </dependencies>
      </api-layer>
    </existing-implementation>

    <reference-architecture>
      <repository url="https://github.com/ferriskey/ferriskey">
        <key-patterns>
          <pattern name="AppState">
            <description>Central state container holding service and configuration</description>
            <location>api/src/application/http/server/app_state.rs</location>
          </pattern>
          <pattern name="Router Organization">
            <description>Domain-specific routers merged into main router</description>
            <location>api/src/application/http/server/http_server.rs</location>
          </pattern>
          <pattern name="Generic Response Wrapper">
            <description>Response&lt;T&gt; wrapper for consistent API responses</description>
            <location>api/src/application/http/server/api_entities/response.rs</location>
          </pattern>
          <pattern name="ApiError">
            <description>Unified error type for HTTP responses</description>
            <location>api/src/application/http/server/api_entities/api_error.rs</location>
          </pattern>
          <pattern name="Health Endpoints">
            <endpoint path="/health/ready" description="Readiness probe - checks database"/>
            <endpoint path="/health/live" description="Liveness probe - simple check"/>
            <location>api/src/application/http/health/</location>
          </pattern>
          <pattern name="Service Creation">
            <description>Dependency injection pattern for service initialization</description>
            <location>core/src/application/create_service</location>
          </pattern>
        </key-patterns>
      </repository>
    </reference-architecture>
  </context>

  <requirements>
    <functional>
      <requirement id="FR-1" priority="critical">
        <description>Implement /health/ready endpoint</description>
        <acceptance-criteria>
          <criterion>Returns 200 OK when database is healthy</criterion>
          <criterion>Returns 503 Service Unavailable when database is unhealthy</criterion>
          <criterion>Response includes: is_healthy (bool), status (string), database health, timestamp</criterion>
          <criterion>Database health check executes actual PostgreSQL ping</criterion>
        </acceptance-criteria>
      </requirement>

      <requirement id="FR-2" priority="critical">
        <description>Implement /health/live endpoint</description>
        <acceptance-criteria>
          <criterion>Returns 200 OK when service is running</criterion>
          <criterion>Lightweight check without database dependency</criterion>
          <criterion>Response includes: status (string), timestamp, message</criterion>
        </acceptance-criteria>
      </requirement>

      <requirement id="FR-3" priority="high">
        <description>Create AppState with dependency injection</description>
        <acceptance-criteria>
          <criterion>AppState holds Service instance</criterion>
          <criterion>Service initialized via DI pattern</criterion>
          <criterion>AppState is Clone-able for Axum state sharing</criterion>
        </acceptance-criteria>
      </requirement>

      <requirement id="FR-4" priority="high">
        <description>Implement Generic Response wrapper</description>
        <acceptance-criteria>
          <criterion>Response&lt;T&gt; provides consistent JSON structure</criterion>
          <criterion>Implements IntoResponse for Axum</criterion>
          <criterion>Supports different HTTP status codes</criterion>
        </acceptance-criteria>
      </requirement>

      <requirement id="FR-5" priority="high">
        <description>Create unified ApiError type</description>
        <acceptance-criteria>
          <criterion>Maps CoreError to appropriate HTTP status codes</criterion>
          <criterion>Implements IntoResponse for automatic error handling</criterion>
          <criterion>Provides user-friendly error messages</criterion>
          <criterion>Handles ServiceUnavailable (503) for health failures</criterion>
        </acceptance-criteria>
      </requirement>

      <requirement id="FR-6" priority="critical">
        <description>Fix PostgresHealthRepository bug</description>
        <acceptance-criteria>
          <criterion>Change is_err() to is_ok() in ping method</criterion>
          <criterion>Health check returns true when database is healthy</criterion>
          <criterion>Add test to prevent regression</criterion>
        </acceptance-criteria>
      </requirement>
    </functional>

    <technical>
      <requirement id="TR-1" priority="critical">
        <description>Add required dependencies to api/Cargo.toml</description>
        <dependencies>
          <dependency name="axum" features="[]" rationale="Web framework"/>
          <dependency name="tokio" features="[full]" rationale="Async runtime"/>
          <dependency name="serde" features="[derive]" rationale="JSON serialization"/>
          <dependency name="serde_json" rationale="JSON handling"/>
          <dependency name="core" workspace="true" rationale="Core business logic"/>
          <dependency name="sqlx" features="[postgres, runtime-tokio, uuid]" rationale="Database"/>
          <dependency name="chrono" features="[serde]" rationale="Timestamps"/>
          <dependency name="uuid" features="[serde, v4]" rationale="IDs"/>
        </dependencies>
      </requirement>

      <requirement id="TR-2" priority="high">
        <description>Follow Ferriskey architectural patterns</description>
        <patterns>
          <pattern>Separate handlers, routers, and validators</pattern>
          <pattern>Use async/await throughout</pattern>
          <pattern>Extract state via State(state): State&lt;AppState&gt;</pattern>
          <pattern>Handler functions return Result&lt;Response&lt;T&gt;, ApiError&gt;</pattern>
          <pattern>Router functions return Router&lt;AppState&gt;</pattern>
        </patterns>
      </requirement>

      <requirement id="TR-3" priority="medium">
        <description>Code organization and modularity</description>
        <structure>
          <module path="api/src/http/health">
            <file name="handler.rs">
              <export>health_ready handler function</export>
              <export>health_live handler function</export>
            </file>
            <file name="router.rs">
              <export>health_routes function returning Router</export>
            </file>
            <file name="mod.rs">
              <export>Re-export public API</export>
            </file>
          </module>
          <module path="api/src/http/server">
            <file name="app_state.rs">AppState struct</file>
            <file name="api_error.rs">ApiError enum</file>
            <file name="response.rs">Response&lt;T&gt; wrapper</file>
            <file name="mod.rs">Module exports</file>
          </module>
        </structure>
      </requirement>

      <requirement id="TR-4" priority="high">
        <description>Update Service generic type parameters</description>
        <changes>
          <change location="core/src/domain/common/services.rs">
            <description>Add HealthRepository generic parameter H</description>
            <current>Service&lt;S, F&gt; where S: ServerRepository, F: FriendshipRepository</current>
            <updated>Service&lt;S, F, H&gt; where S: ServerRepository, F: FriendshipRepository, H: HealthRepository</updated>
          </change>
        </changes>
      </requirement>
    </technical>

    <constraints>
      <constraint id="C-1" type="scope">
        <description>No CORS configuration</description>
        <rationale>Not needed for this iteration</rationale>
      </constraint>

      <constraint id="C-2" type="scope">
        <description>No logging/tracing setup</description>
        <rationale>Out of scope for initial implementation</rationale>
      </constraint>

      <constraint id="C-3" type="scope">
        <description>No OpenAPI/Swagger documentation</description>
        <rationale>Can be added later if needed</rationale>
      </constraint>

      <constraint id="C-4" type="scope">
        <description>No root path prefix configuration</description>
        <rationale>Routes at root level for simplicity</rationale>
      </constraint>

      <constraint id="C-5" type="architectural">
        <description>Must follow existing hexagonal architecture</description>
        <rationale>Consistency with project structure</rationale>
      </constraint>
    </constraints>
  </requirements>

  <implementation-plan>
    <phase number="1" name="Fix Critical Bug">
      <task id="1.1" priority="critical">
        <file>core/src/infrastructure/health/repositories/postgres.rs</file>
        <action>Fix PostgresHealthRepository::ping() method</action>
        <change>Replace is_err() with is_ok()</change>
      </task>
    </phase>

    <phase number="2" name="Update Core Service">
      <task id="2.1" priority="high">
        <file>core/src/domain/common/services.rs</file>
        <action>Add HealthRepository generic parameter</action>
        <details>
          <step>Add H: HealthRepository to struct generic parameters</step>
          <step>Add health_repository: H field to struct</step>
          <step>Update new() constructor to accept health_repository</step>
          <step>Update all trait implementations to include H parameter</step>
        </details>
      </task>
    </phase>

    <phase number="3" name="Create API Infrastructure">
      <task id="3.1" priority="high">
        <file>api/Cargo.toml</file>
        <action>Add all required dependencies</action>
        <dependencies>axum, tokio, serde, serde_json, core, sqlx, chrono, uuid</dependencies>
      </task>

      <task id="3.2" priority="high">
        <file>api/src/http/server/mod.rs</file>
        <action>Create module structure</action>
        <exports>app_state, api_error, response</exports>
      </task>

      <task id="3.3" priority="high">
        <file>api/src/http/server/response.rs</file>
        <action>Implement generic Response&lt;T&gt; wrapper</action>
        <details>
          <struct name="Response&lt;T&gt;">
            <method>OK(T) -> Response&lt;T&gt;</method>
            <implementation>IntoResponse for Axum</implementation>
          </struct>
        </details>
      </task>

      <task id="3.4" priority="high">
        <file>api/src/http/server/api_error.rs</file>
        <action>Create unified error type</action>
        <details>
          <enum name="ApiError">
            <variant>ServiceUnavailable(String)</variant>
            <variant>InternalServerError(String)</variant>
            <implementation>From&lt;CoreError&gt;</implementation>
            <implementation>IntoResponse for Axum</implementation>
          </enum>
        </details>
      </task>

      <task id="3.5" priority="high">
        <file>api/src/http/server/app_state.rs</file>
        <action>Create AppState with DI</action>
        <details>
          <struct name="AppState">
            <field>service: Arc&lt;Service&lt;S, F, H&gt;&gt;</field>
            <derive>Clone</derive>
            <method>new() constructor</method>
          </struct>
        </details>
      </task>
    </phase>

    <phase number="4" name="Implement Health Handlers">
      <task id="4.1" priority="high">
        <file>api/src/http/health/handler.rs</file>
        <action>Implement health_ready handler</action>
        <details>
          <function name="health_ready">
            <signature>async fn(State&lt;AppState&gt;) -> Result&lt;Response&lt;ReadinessResponse&gt;, ApiError&gt;</signature>
            <logic>
              <step>Call state.service.check_health()</step>
              <step>Map IsHealthy to ReadinessResponse</step>
              <step>Include timestamp using chrono::Utc::now()</step>
              <step>Return 200 OK or error</step>
            </logic>
          </function>
          <struct name="ReadinessResponse">
            <field>is_healthy: bool</field>
            <field>status: String</field>
            <field>database_status: String</field>
            <field>timestamp: String</field>
            <derive>Serialize, Debug, Clone</derive>
          </struct>
        </details>
      </task>

      <task id="4.2" priority="high">
        <file>api/src/http/health/handler.rs</file>
        <action>Implement health_live handler</action>
        <details>
          <function name="health_live">
            <signature>async fn(State&lt;AppState&gt;) -> Result&lt;Response&lt;LivenessResponse&gt;, ApiError&gt;</signature>
            <logic>
              <step>No database check - always returns OK</step>
              <step>Create LivenessResponse with timestamp</step>
              <step>Return 200 OK</step>
            </logic>
          </function>
          <struct name="LivenessResponse">
            <field>status: String</field>
            <field>timestamp: String</field>
            <field>message: String</field>
            <derive>Serialize, Debug, Clone</derive>
          </struct>
        </details>
      </task>
    </phase>

    <phase number="5" name="Create Router">
      <task id="5.1" priority="high">
        <file>api/src/http/health/router.rs</file>
        <action>Create health_routes function</action>
        <details>
          <function name="health_routes">
            <signature>pub fn health_routes() -> Router&lt;AppState&gt;</signature>
            <routes>
              <route path="/health/ready" method="GET" handler="health_ready"/>
              <route path="/health/live" method="GET" handler="health_live"/>
            </routes>
          </function>
        </details>
      </task>

      <task id="5.2" priority="high">
        <file>api/src/http/health/mod.rs</file>
        <action>Update module exports</action>
        <exports>
          <export>pub use handler::{health_ready, health_live}</export>
          <export>pub use router::health_routes</export>
        </exports>
      </task>
    </phase>

    <phase number="6" name="Main Application Setup">
      <task id="6.1" priority="high">
        <file>api/src/http/mod.rs</file>
        <action>Add server module</action>
        <change>Add: pub mod server;</change>
      </task>

      <task id="6.2" priority="high">
        <file>api/src/main.rs</file>
        <action>Implement main function with DI</action>
        <details>
          <function name="main">
            <attributes>#[tokio::main]</attributes>
            <logic>
              <step>Initialize database connection pool</step>
              <step>Create repository instances (PostgresHealthRepository, etc.)</step>
              <step>Create Service with dependency injection</step>
              <step>Create AppState wrapping service</step>
              <step>Build Axum router merging health_routes()</step>
              <step>Start HTTP server on port 3000</step>
            </logic>
          </function>
        </details>
      </task>
    </phase>

    <phase number="7" name="Integration">
      <task id="7.1" priority="medium">
        <file>api/src/lib.rs</file>
        <action>Ensure proper module exports</action>
      </task>

      <task id="7.2" priority="high">
        <file>core/src/lib.rs</file>
        <action>Export necessary types for API layer</action>
        <exports>Re-export service creation utilities if needed</exports>
      </task>
    </phase>
  </implementation-plan>

  <verification>
    <acceptance-tests>
      <test id="AT-1">
        <description>Health endpoints compilation</description>
        <command>cargo build</command>
        <expected>Clean compilation without errors</expected>
      </test>

      <test id="AT-2">
        <description>Health ready endpoint responds correctly</description>
        <command>curl http://localhost:3000/health/ready</command>
        <expected>
          <status-code>200</status-code>
          <response-structure>
            {
              "is_healthy": true,
              "status": "healthy",
              "database_status": "healthy",
              "timestamp": "2025-11-15T..."
            }
          </response-structure>
        </expected>
      </test>

      <test id="AT-3">
        <description>Health live endpoint responds correctly</description>
        <command>curl http://localhost:3000/health/live</command>
        <expected>
          <status-code>200</status-code>
          <response-structure>
            {
              "status": "ok",
              "timestamp": "2025-11-15T...",
              "message": "Service is live"
            }
          </response-structure>
        </expected>
      </test>

      <test id="AT-4">
        <description>Health check fails gracefully when DB is down</description>
        <scenario>Stop PostgreSQL container</scenario>
        <command>curl http://localhost:3000/health/ready</command>
        <expected>
          <status-code>503</status-code>
          <error-message>Service Unavailable</error-message>
        </expected>
      </test>
    </acceptance-tests>

    <code-quality>
      <criterion>All code follows Rust idioms and best practices</criterion>
      <criterion>No compiler warnings</criterion>
      <criterion>Proper error handling throughout</criterion>
      <criterion>Clear separation of concerns (handlers, routers, state)</criterion>
      <criterion>Consistent naming conventions with ferriskey reference</criterion>
      <criterion>All public APIs documented with doc comments</criterion>
    </code-quality>
  </verification>

  <deliverables>
    <deliverable id="D-1">
      <description>Updated core/src/domain/common/services.rs with HealthRepository</description>
      <status>required</status>
    </deliverable>

    <deliverable id="D-2">
      <description>Fixed core/src/infrastructure/health/repositories/postgres.rs</description>
      <status>required</status>
    </deliverable>

    <deliverable id="D-3">
      <description>Complete api/Cargo.toml with dependencies</description>
      <status>required</status>
    </deliverable>

    <deliverable id="D-4">
      <description>api/src/http/server module (app_state.rs, api_error.rs, response.rs, mod.rs)</description>
      <status>required</status>
    </deliverable>

    <deliverable id="D-5">
      <description>api/src/http/health module (handler.rs, router.rs, mod.rs)</description>
      <status>required</status>
    </deliverable>

    <deliverable id="D-6">
      <description>Working api/src/main.rs with complete DI setup</description>
      <status>required</status>
    </deliverable>

    <deliverable id="D-7">
      <description>Updated module declarations (api/src/http/mod.rs)</description>
      <status>required</status>
    </deliverable>

    <deliverable id="D-8">
      <description>Compilable and runnable application</description>
      <status>required</status>
    </deliverable>
  </deliverables>

  <notes>
    <architectural-decisions>
      <decision id="AD-1">
        <description>Use Arc&lt;Service&gt; in AppState for thread-safe shared ownership</description>
        <rationale>Axum clones state for each request handler</rationale>
      </decision>

      <decision id="AD-2">
        <description>Separate ReadinessResponse and LivenessResponse types</description>
        <rationale>Different endpoints have different response structures</rationale>
      </decision>

      <decision id="AD-3">
        <description>Map CoreError::Unhealthy to HTTP 503</description>
        <rationale>Standard status code for service unavailability</rationale>
      </decision>

      <decision id="AD-4">
        <description>Keep validator.rs empty for now</description>
        <rationale>Health endpoints don't require input validation</rationale>
      </decision>
    </architectural-decisions>

    <future-enhancements>
      <enhancement priority="low">Add OpenAPI documentation with utoipa</enhancement>
      <enhancement priority="low">Add structured logging with tracing</enhancement>
      <enhancement priority="low">Add CORS configuration support</enhancement>
      <enhancement priority="medium">Add unit tests for handlers</enhancement>
      <enhancement priority="medium">Add integration tests</enhancement>
      <enhancement priority="low">Add metrics endpoint</enhancement>
      <enhancement priority="low">Add configurable health check thresholds</enhancement>
    </future-enhancements>

    <references>
      <reference>
        <url>https://github.com/ferriskey/ferriskey</url>
        <description>Reference architecture and patterns</description>
      </reference>
      <reference>
        <url>https://github.com/beep-industries/communities/issues/5</url>
        <description>Original GitHub issue</description>
      </reference>
      <reference>
        <url>https://docs.rs/axum/latest/axum/</url>
        <description>Axum web framework documentation</description>
      </reference>
      <reference>
        <url>https://alistair.cockburn.us/hexagonal-architecture/</url>
        <description>Hexagonal architecture principles</description>
      </reference>
    </references>
  </notes>
</task>
